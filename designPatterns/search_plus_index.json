{"./":{"url":"./","title":"Introduction","keywords":"","body":"My Awesome Book This file file serves as your book's preface, a great place to describe your book's content and ideas.sdaads graph TD; A-->B; A-->C; B-->D; C-->D; D-->A; **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"chapter1.html":{"url":"chapter1.html","title":"First Chapter","keywords":"","body":"First Chapter GitBook allows you to organize your book into chapters, each chapter is stored in a separate file like this one. https://www.cnblogs.com/chengxiao/p/6059914.html Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"guo-cheng-yu-dui-xiang.html":{"url":"guo-cheng-yu-dui-xiang.html","title":"过程与对象","keywords":"","body":"面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向对象是把构成问题的事务分解成各个对象，然而建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题步骤中的行为，也就是一个对象能提供什么样的行为来解决整个问题中的一部分。而对象的形成是类对事物的抽象，面向对象的三个基本特征： 抽象 抽象即提取现实世界中某事物的关键特性，这些关键特性成为该事物构建的模型。然而对同一事物在不同的需求下，需要提取的特性可能不一样。提取的抽象模型中一般包含：属性（数据）和操作（行为）这个抽象模型我们称之为类而对类进行实例化得到是对象。类用来表示某一事物的特性，那么对象呢？ 概念层面讲：对象是某种拥有责任的抽象 规格层面讲：对象是一系列可以被其他对象使用的公共接口 语言实现层面来看：对象封装了代码和数据 封装 封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等） 继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。而继承是一种能够获取能力的功能，也就是可以使用继承来对现有类获取被继承类的功能，并且还可以在无需重新编写父类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承概念的实现方式有两类：实现继承和接口继承： 实现继承是指使用基类的属性和方法而无需额外编码的能力。 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。 OOP开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。 多态 多态性本质上是一种技术在Java中称为动态解析，这种技术能够将子类类型的指针赋值给父类类型的指针，也就是父类引用可以指向子类对象的一种技术。而这种技术是在继承的基础上实现的同时重写继承方法和父类引用指向子类对象，这也就是形成多态必须三个要素：继承、重写和父类引用指向子类对象。 父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为就是类多态特性但是这种多态性jvm分成编译时多态和运行时多态也就是静态解析和动态解析。 重载是多态性的表现吗？ 重载是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同），其实重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。 结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。” 那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。 interfac A{ } A a = new Aa() ; a = new Ab() ; 由这三种特性封装，继承和多态定义了面向对象 graph LR; e(事物); a((抽象)); b((继承)); c((多态)); f(类); e--提取特性-->a; a--封装-->f; f--扩展-->b; b--重写-->c; Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"guo-cheng-yu-dui-xiang/oop.html":{"url":"guo-cheng-yu-dui-xiang/oop.html","title":"OOP","keywords":"","body":"软件开发中疑难问题： 软件复杂庞大 很多软件进入维护阶段 需求的不断变更 软件开发中存在很多其他的问题，上面只是从程序开发和设计的角度看到的部分问题。需求解决上面软件开发中的问题，就要求我们编写（设计）的软件具有很好的可读性、可维护性和可扩展性。我们需要保证代码具有高内聚低耦合。 下面将简单介绍面向对象的一些基本特性、设计原则，以及设计模式关系。 四大基本特性： 抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类而对类进行实例化得到是对象。 对象：从概念层面讲，对象是某种拥有责任的抽象。 – 从规格层面讲，对象是一系列可以被其他对象使用的公共接口。 – 从语言实现层面来看，对象封装了代码和数据。 封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等） 继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。 多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。 抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。 七大设计原则： SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则） 迪米特法则 组合优于继承原则（合成复用原则）。 在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。 24种设计模式(gof23+1)： 创建型模式： 简单工厂模式（不包含在gof23中） 工厂模式 抽象工厂模式 单例模式 原型模式 创建者模式 结构型模式： 组合模式 装饰者模式 外观模式 适配器模式 代理模式 享元模式 桥接模式 行为型模式： 观察者模式 策略模式 状态模式 中介模式 模板方法 命令模式 备忘录模式 访问者模式 解释器模式 迭代器模式 职责链模式 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi.html":{"url":"she-ji-mo-shi.html","title":"设计原则","keywords":"","body":"设计原则与面向对象 面向对象的三大机制“封装、继承、多态” 可以表达面向对象的所有概念，但这三大机制本身并没有刻画出面向对象的核心精神。换言之，既可以用这三大机制做出“好的面向对象设计”，也可以用这三大机制做出“差的面向对象设计”。因此不是使用了面向对象的语言，就实现了”好的面向对象设计”! 而所谓“好的面向对象设计”是那些可以满足“应对变化，提高复用”的设计称之为“好的设计” 要实现“好的设计” 需要遵循 “针对接口编程，而不是针对实现编“, ”优先使用对象组合，而不是类继承“ 以及 “封装变化点”，这三点的基石就是 “开-闭原则”，也就是面向对象设计的基石是“开-闭”原则。 面向对象设计的基石 “开—闭”原则 [软件实体应当对扩展开放，对修改关闭] 这个原则说的是在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，其本质是找出哪些因素是在系统中存在可变情况并将其进行封装也就是所谓的“可变性封装原则”。“ 做到“开—闭”原则不是一件容易的事，它是面向对象设计的终极目标，但是也有很多规律可循，这些规律同样也是设计原则而它们是实现开—闭原则的具体方法： 里氏代换原则（LSP） 这种方法通过提高基类的复用，在需求变化的时候可以通过子类扩张，无需修改。 依赖倒转原则（DIP） \"开-闭\"原则与依赖倒转原则是目标和手段的关系。如果说开闭原则是目标,依赖倒转原则是到达\"开闭\"原则的手段。如果要达到最好的\"开闭\"原则,就要尽量的遵守依赖倒转原则，依赖倒转原则是对\"抽象化\"的最好规范。里氏代换原则是依赖倒转原则的基础，依赖倒转原则是里氏代换原则的重要补充。 接口隔离原则（ISP） 接口实现等 熟悉一些典型的面向对象设计模式 使用重构得到模式——设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。目前普遍公认的最好的使用设计模式的方法。 几条更具体的设计原则 单一职责原则（SRP）： – 一个类应该仅有一个引起它变化的原因。 开放封闭原则（OCP）： – 类模块应该是可扩展的，但是不可修改（对扩展开放，对更改封闭） Liskov 替换原则（LSP）: – 子类必须能够替换它们的基类 – 依赖倒置原则（DIP）： – 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。 – 抽象不应该依赖于实现细节，实现细节应该依赖于抽象。 接口隔离原则（ISP）： – 不应该强迫客户程序依赖于它们不用的方法。 总结 设计模式描述了软件设计过程中某一类常见问题的一般性的解决方案。面向对象设计模式描述了面向对象设计过程中、特定场景下、类与相互通信的对象之间常见的组织关系。 深刻理解面向对象是学好设计模式的基础，掌握一定的面向对象设计原则才能把握面向对象设计模式的精髓，从而实现灵活运用设计模式。 三大基本面向对象设计原则 – 针对接口编程，而不是针对实现编程 – 优先使用对象组合，而不是类继承 – 封装变化点 使用重构得到模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。 附:面向对象设计原则 面向对象设计的基石是“开—闭”原则。 “开一闭”原则讲的是：一个软件实体应当对扩展开放，对修改关闭。 这个规则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。 从另外一个角度讲，就是所谓的“对可变性封装原则”。“对可变性封装原则”意味着两点： 1 .一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里面。同一种可变性的不同表象意味着同一个继承等级结构中的具体子类。 2.一种可变性不应当与另一种可变性混合在一起。即类图的继承结构一般不应超过两 做到“开—闭”原则不是一件容易的事，但是也有很多规律可循，这些规律同样也是设计原则，它们是实现开—闭原则的工具。 里氏代换原则 里氏代换原则：如果对每一个类型为T1的对象o1,都有类型为T2的对象o2，使得以T1定义的所有程序P在所有对象o1都换成o2时，程序P的行为没有变化，那么类型T2是T1的子类型。 即如果一个软件实体使用的是基类的话那么也一定适用于子类。但反过来的代换不成立。 如果有两个具体类A和B之间的关系违反了里氏代换原则，可以在以下两种重构方案中选择一种： 1 创建一个新的抽象类C,作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全一致的问题。 2 从B到A的继承关系改写为委派关系。 依赖倒转原则 依赖倒转原则讲的是：要依赖于抽象，不要依赖于具体。即针对接口编程，不要针对实现编程。针对接口编程的意思是，应当使用接口和抽象类进行变量的类型声明、参量的类型声明，方法的返还类型声明，以及数据类型的转换等。不要针对实现编程的意思就是说，不应当使用具体类进行变量的类型声明、参量的类型声明，方法的返还类型声明，以及数据类型的转换等。 依赖倒转原则虽然强大，但却不易实现，因为依赖倒转的缘故，对象的创建很可能要使用对象工厂，以避免对具体类的直接引用，此原则的使用还会导致大量的类。维护这样的系统需要较好的面向对象的设计知识。 此外，依赖倒转原则假定所有的具体类都是变化的，这也不总是正确的。有一些具体类可能是相当稳定、不会发生变化的，消费这个具体类实例的客户端完全可以依赖于这个具体类。 接口隔离原则 接口隔离原则讲的是：使用多个专门的接口比使用单一的接口要好。从客户的角度来说：一个类对另外一个类的依赖性应当是建立在最小的接口上的。如果客户端只需要某一些方法的话，那么就应当向客户端提供这些需要的方法，而不要提供不需要的方法。提供接口意味着向客户端作出承诺，过多的承诺会给系统的维护造成不必要的负担。 合成、聚合复用原则 合成、聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部份，新的对象通过向这些对象的委派达到复用已有功能的目的。这个原则有一个简短的描述：要尽量使用合成、聚合，尽量不要使用继承。 合成、聚合有如下好处： 新对象存取成分对象的唯一方法是通过成分对象的接口。 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不到的。 这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象。 合成、聚合可以应用到任何环境中去，而继承只能应用到一些有限环境中去。 导致错误的使用合成、聚合与继承的一个常见原因是错误的把“Has-a”关系当作“Is-a”关系。如果两个类是“Has-a”关系那么应使用合成、聚合，如果是“Is-a”关系那么可使用继承。 迪米特法则 迪米特法则说的是一个对象应该对其它对象有尽可能少的了解。即只与你直接的朋友通信，不要跟陌生人说话。如果需要和陌生人通话，而你的朋友与陌生人是朋友，那么可以将你对陌生人的调用由你的朋友转发，使得某人只知道朋友，不知道陌生人。换言之，某人会认为他所调用的是朋友的方法。 以下条件称为朋友的条件： 当前对象本身。 以参量的形式传入到当前对象方法中的对象。 当前对象的实例变量直接引用的对象。 当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友。 当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的朋友，否则就是陌生人。 迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点： 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。 在类的设计上，只要有可能，一个类应当设计成不变类。 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"ke-bian-xing-de-feng-zhuang-yuan-ze.html":{"url":"ke-bian-xing-de-feng-zhuang-yuan-ze.html","title":"可变性的封装原则","keywords":"","body":"对可变性的封装原则即找到一个系统的可变因素将之封装起来,换言之在设计时什么可能会发生变化应使之成为抽象层被封装，而不是什么会导致设计改变才封装。对可变性封装原则”意味着两点： 1.一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里面。同一种可变性的不同表象意味着同一个继承等级结构中的具体子类。 2.一种可变性不应当与另一种可变性混合在一起。即类图的继承结构一般不应超过两个。(高内聚-低耦合) 对人类进行其抽象其分为男和女以及他们共有的特性名称，性别以及其他属性均不存在可变性，但是客观存在的男女是有一定的区别，这些区别就是可变因素，如method 就是将可变因素封装在抽象层，让其不同的子类（性别）去实现各自的行为，如出现ManAndWomen类人只需进行method扩张无需修改抽象层-这就是”对可变性的封装原则“也是开闭原则的定义-“对修改关闭，扩张开发“。 可变性的封装原则其核心就是对事物抽象化也就是对它进行概括归纳其本质，找出可变因素进行封装于抽象层，而抽象层在面向对象语言中是由抽象类或者接口定义，规定其特征或者实现不可变因素，抽象可变因素再由具体化导出不同的实现达到开闭原则效果。 面向对象设计的重要原则是创建抽象化并且从抽象化导出具体化，具体化给出不同的实现。继承关系就是一种从抽象化到具体化的导出。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"lsp.html":{"url":"lsp.html","title":"里氏代换原则(LSP)","keywords":"","body":"里氏代换原则(Liskov Substitution Principle LSP)是面向对象设计的基本原则之一它是这样定义的任何基类可以出现的地方，子类一定可以出现。 从另一方面LSP也是继承复用的基石，继承复用是这样定义的只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 里氏代换关系的基石就是继承，并不是存在继承关系也符合里氏代换原则，还需要满足子类替换基类不会影响功能。 一个正方类继承长方形类但他们之间不符合LSP原则，因为子类替换基类后会对软件功能有影响 如下： //长 public class Rectangle { private int width ; private int height ; public int getWidth() { return width; } public int getHeight() { return height; } public void setWidth(int width){ this.width=width; } public void setHeight(int height){ this.height=height ; } } //正 public class Square extends Rectangle { @Override public void setWidth(int width){ super.setWidth(width); super.setHeight(width); } @Override public void setHeight(int height){ setWidth(height); } } 功能：测试传入的长方形的宽度是否大于高度，如果满足就停止下来，否则就增加宽度的值，使用基类没任何问题，根据LSP把基类替换成它的子类结果应该也是一样的，但是使用子类该方法永远都不能满足条件（w和h相等），这种替换直接影响了软件的功能，属于不符号LSP原则 违反了LSP的重构设计 如果两个具体的类A，B之间的关系违反了LSP的设计，(假设是从B到A的继承关系)那么根据具体的情况可以在下面的两种重构方案中选择一种。 依据可变性封装原则进行重构-找出不可变因素以及抽象抽象层 在该例子中长方形和正方形都属于四变形类，而他们不可变因素是长和高属性的获取行为，可变因素是对其属性设置的行为如下： 这样正式是可变性原则中描述：“同一种可变性的不同表象,意味着同一个继承等级结构中的具体子类 ” ，将共有的行为定义在父类中，子类各自实现，如上例子中这样的设计符号LSP原则 从B到A的继承关系改为委派关系。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"yi-lai-dao-zhi-yuan-ze.html":{"url":"yi-lai-dao-zhi-yuan-ze.html","title":"依赖倒置原则(DIP)","keywords":"","body":"依赖倒转原则就是要依赖于抽象，不要依赖于实现。要针对接口编程，不要针对实现编程，而倒转指的是面向对象中层级的依赖与面向过程中层级依赖的转换。 具体的说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等。而不要用具体类进行变量的类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等。 要保证做到这一点，一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法。这也更加具体描述了实现开-闭原则的过程。 依赖在面向过程和面向对象开发中的转变 传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒转原则就是把这个错误的层级依赖关系倒转过来。 抽象层 面向对象设计的重要原则是可变性封装原则，在此原则中对可变因素的封装是由抽象层定义，而抽象层包含的应该是应用系统的商务逻辑和宏观的定义、对整个系统来说重要的战略性决定，是必然性的体现。 具体层 具体层次含有的是一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有相当大的偶然性选择。具体层次的代码是经常变动的，不能避免出现错误。 从复用的角度来说，高层次的模块是应当复用的，而且是复用的重点，因为它含有一个应用系统最重要的宏观商务逻辑，是较为稳定的。而在传统的过程性设计中，复用则侧重于具体层次模块的复用。依赖倒转原则则是对传统的过程性设计方法的“倒转”，是高层次模块复用及其可维护性的有效规范。 特例： 对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"isp.html":{"url":"isp.html","title":"接口隔离原则(ISP)","keywords":"","body":"接口隔离原则针对的是对接口上的依赖程度。首先接口分为两种： 实例接口（Object Interface） 在Java中声明一个类，然后用new关键字产生的一个实例，它是对一个类型的事物的描述，这也是一种接口。 如： 定义Person这个类，然后使用Person zhangSan = new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口，Java中的类也是一种接口. 类接口（Class Interface） Java中经常使用的interface关键字定义的接口。 其次隔离，它也有两种定义： “Clients should not be forced to depend upon interfaces that they don't use”——客户端不应该依赖它不需用的接口。 那依赖什么？只给客服端供它需要的接口，把不需要的接口剔除掉，那就需要对接口进行细化。 “The dependency of one class to another one should depend on the smallest possible interface”——类间的依赖关系应该建立在最小的接口上。 它要求也是最小的接口，也是要求接口细化，提供接口单一 两种定义如出一辙，只是一个事物的两种不同描述，统一描述也就是 “接口尽量细化，同时接口中的方法尽量少“。 “接口尽量细化，同时接口中的方法尽量少“与单一职责原则是否存在冲突？ 接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分(对外提供业务服务)，而接口隔离原则要求接口的方法尽量少。 通过对接口细化，最后由一个业务对象统一实现，在使用时不同的系统提供不同的接口，这样也就实现了接口隔离（提供的服务） 例如： 一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”， 按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”,专门的接口指什么？就是指提供给每个模块都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"he-6210-ju-he-fu-yong-yuan-ze.html":{"url":"he-6210-ju-he-fu-yong-yuan-ze.html","title":"合成/聚合复用原则","keywords":"","body":"概念定义 在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，且新的对象通过向这些对象的委派达到复用这些对象的目的。 应首先使用\"合成/聚合\"，\"合成/聚合\"则使系统灵活，其次才考虑继承，达到复用的目的。复用指的的类的复用1 而使用继承时，要严格遵循里氏代换原则。有效地使用继承会有助于对问题的理解，降低复杂度，而滥用继承会增加系统构建、维护时的难度及系统的复杂度。 如果两个类是“Has-a”关系应使用合成/聚合，如果是“Is-a”关系可使用继承 \"Is-A\"是严格的分类学意义上定义，意思是一个类是另一个类的\"一种变体\" ,而\"Has-A\"则不同，它表示某一个角色具有某一项责任。 什么是合成?什么是聚合？ 合成（Composition）和聚合（Aggregation）都是关联（Association）的特殊种类。 聚合表示整体和部分的关系，表示“拥有”。如奔驰S360汽车，对奔驰S360引擎、奔驰S360轮胎的关系是聚合关系，离开了奔驰S360汽车，引擎、轮胎就失去了存在的意义。在设计中, 聚合不应该频繁出现，这样会增大设计的耦合度。 合成则是一种更强的“拥有”，部分和整体的生命周期一样。合成的新的对象完全支配其组成部分，包括它们的创建和湮灭等。一个合成关系的成分对象是不能与另一个合成关系共享的。 换句话说，合成是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。 明白了合成和聚合关系，再来理解合成/聚合原则应该就清楚了，要避免在系统设计中出现，一个类的继承层次超过3层，则需考虑重构代码，或者重新设计结构。当然最好的办法就是考虑使用合成/聚合原则。 通过合成/聚合来进行复用的优缺点 优点: 新对象存取成分对象的唯一方法是通过成分对象的接口。 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的。 这种复用支持包装。 这种复用所需的依赖较少。 每一个新的类可以将焦点集中在一个任务上。 这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象。 作为复用手段可以应用到几乎任何环境中去。 缺点:就是系统中会有较多的对象需要管理。 通过继承来进行复用的优缺点 优点 新的实现较为容易，因为超类的大部分功能可以通过继承的关系自动进入子类。 修改和扩展继承而来的实现较为容易。 缺点 继承复用破坏包装，因为继承将超类的实现细节暴露给子类。由于超类的内部细节常常是对于子类透明的，所以这种复用是透明的复用，又称“白箱”复用。 如果超类发生改变，那么子类的实现也不得不发生改变。 从超类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。 继承只能在有限的环境中使用。 此部分引用自：http://www.cnblogs.com/temptation/archive/2008/03/10/1098351.html Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-11-11 09:58:31 "},"dan-yi-zhi-ze-yuan-ze.html":{"url":"dan-yi-zhi-ze-yuan-ze.html","title":"单一职责原则","keywords":"","body":"一个类，应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。我们可能只需要复用该类的某一个职责，但这个职责跟其它职责耦合在了一起，很难分离出来， SRP中，把职责定义为“变化的原因”。如果你能想到N个动机去改变一个类，那么这个类就具有多于一个的职责。这里说的“变化的原因”，只有实际发生时才有意义。可能预测到会有多个原因引起这个类的变化，但这仅仅是预测，并没有真的发生，这个类仍可看做具有单一职责，不需要分离职责。如果分离，会带来不必要的复杂性。 如果发现一个类有多于一个的职责，应该尽量解耦。如果很难解耦，也要分离接口，在概念上解耦。 众所周知，OOPL可以提高程序的封装性、复用性、可维护性。但仅仅是“可以”。能不能实现OOPL的这些优点，要看具体怎么做。如果一个类的代码非常混乱，各种功能的代码都混在一起，封装性、复用性、可维护性无从谈起。 SRP是所有原则中最简单的，也是最基本的一个。运用这个原则，可以提高类的内聚性，有助于充分发挥OOPL的优势。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"di-mi-te-fa-ze.html":{"url":"di-mi-te-fa-ze.html","title":"迪米特法则","keywords":"","body":"5.1概述 定义：一个软件实体应当尽可能少的与其他实体发生相互作用。 这样，当一个模块修改时，就会尽量少的影响其他的模块。扩展会相对容易。 这是对软件实体之间通信的限制。它要求限制软件实体之间通信的宽度和深度。 5.2迪米特法则的其他表述： 1）只与你直接的朋友们通信。 2）不要跟“陌生人”说话。 3）每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 5.3狭义的迪米特法则 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 朋友圈的确定 “朋友”条件： 1）当前对象本身（this） 2）以参量形式传入到当前对象方法中的对象 3）当前对象的实例变量直接引用的对象 4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 5）当前对象所创建的对象 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。 缺点：会在系统里造出大量的小方法，散落在系统的各个角落。 与依赖倒转原则互补使用 5.4狭义的迪米特法则的缺点： 在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关。 遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。 5.5迪米特法则与设计模式 门面（外观）模式和调停者（中介者）模式实际上就是迪米特法则的具体应用。 5.6广义的迪米特法则 迪米特法则的主要用意是控制信息的过载。在将迪米特法则运用到系统设计中时，要注意下面的几点： 1）在类的划分上，应当创建有弱耦合的类。 2）在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 3）在类的设计上，只要有可能，一个类应当设计成不变类。 4）在对其他类的引用上，一个对象对其对象的引用应当降到最低。 5.7广义迪米特法则在类的设计上的体现 1）优先考虑将一个类设置成不变类 2）尽量降低一个类的访问权限 3）谨慎使用Serializable 4）尽量降低成员的访问权限 5）取代C Struct 迪米特法则又叫作最少知识原则（Least Knowledge Principle或简写为LKP），就是说一个对象应当对其他对象有尽可能少的了解。 5.8如何实现迪米特法则 迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点： 1) 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。 2) 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。 3) 在类的设计上，只要有可能，一个类应当设计成不变类。 4) 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-yuan-ze-he-she-ji-mo-shi.html":{"url":"she-ji-yuan-ze-he-she-ji-mo-shi.html","title":"设计原则和设计模式","keywords":"","body":"设计原则定义的是类抽象，而设计模式是类和类之间的组织关系 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/she-ji-mo-shi.html":{"url":"she-ji-mo-shi/she-ji-mo-shi.html","title":"设计模式","keywords":"","body":"什么是设计模式？ 设计模式描述了软件设计过程中某一类常见问题的一般性的解决方案，面向对象设计模式描述了面向对象设计过程中、特定场景下、类与相互通信的对象之间常见的组织关系- 其目的是在不断变化中提高代码的复用。 设计模式按照使用场景可以分为三大类 创建型模式 （Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） graph TD; A( 设计模式 )-->B( 创建型模式 ) A-->C( 结构型模型 ) A-->D( 行为型模型 ) B-->b1( 工厂模式 ) B-->b2( 原型模式 ) D-->d1( 模版模式 ) C-->c1( 装饰模式 ) Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/she-ji-mo-shi/xing-wei-xing-mo-shi.html":{"url":"she-ji-mo-shi/she-ji-mo-shi/xing-wei-xing-mo-shi.html","title":"行为型模式","keywords":"","body":"行为模式：类的行为和行为之间的组织关系 行为模式不仅表达了对象和类，还表达了他们之间的交互，涉及到了对象和算法的分配。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/mo-ban-mo-shi.html":{"url":"she-ji-mo-shi/mo-ban-mo-shi.html","title":"模板模式","keywords":"","body":"模版模式是定义一个抽象类并且实现一个方法该方法称为模版方法，以及该方法负责定义了该类提供的整个行为的逻辑过程，对其中可变行为抽象由同一继承等级提供不同表象的子类实现。 如图：就是模版设计模式，它符合开-闭原则，抽象类Stencil实现了控制顶级逻辑骨架的方法stencil()，具体不同的表象由子类实现 适用于：要提供一个功能，但是该功能是由不同的行为组合执行完成的，并且不同的行为表现不一样。 stencil方法控制了整个业务执行的逻辑，而a和b方法是提供部分行为，并且是可变的，所以定义其抽象满足“修改关闭，扩张开放”的原则 在Spring中提供Dao连接的设计就是采用模版设计模式,不同的连接方式实现不同的配置项由模版方法afterPropertiesSet进行控制： DaoSupport和JdbcAccessor都是模版类，而他们的模版方法都是实现了统一的接口InitializingBean的afterPropertiesSet方法，区别在与DaoSupport抽象类不同数据源的具体，而JdbcAccessor直接定义类JDBC数据源模版方法的实现如下： public void afterPropertiesSet() { if (getDataSource() == null) { throw new IllegalArgumentException(\"Property 'dataSource' is required\"); } if (!isLazyInit()) { getExceptionTranslator(); } } DaoSupport 却抽象出不同的数据访问方式如： //同一行为，由不同表现的子类实现 protected abstract void checkDaoConfig(); @Override public final void afterPropertiesSet() { checkDaoConfig(); initDao(); } //同一行为，由不同表现的子类实现 protected void initDao() throws Exception { } Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/ce-lve-mo-shi.html":{"url":"she-ji-mo-shi/ce-lve-mo-shi.html","title":"策略模式","keywords":"","body":"策略模式适用场景 根据参数或者内容选择不同的表象。 策略模式定义 包含两个角色： 决策者：负责依据参数或者内容选择不同的策略实现者 策略：实现具体的策略 策略类是一个抽象层实现了不变的行为，对可变行为进行抽象定义由同一继承等级的不同的表象子类实现，符合里氏代换原则-提高基类的复用。 在Spring中获取资源是通过定义的字符串中表达式的不同会选择不同的解析过程如下： 如下决策者中的决策方法选择不同的策略 class DefaultResourceLoader{ public Resource getResource(String location) { for (ProtocolResolver protocolResolver : this.protocolResolvers) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } if (location.startsWith(\"/\")) { return getResourceByPath(location); } else if ..... } } Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/guan-cha-zhe-mo-shi.html":{"url":"she-ji-mo-shi/guan-cha-zhe-mo-shi.html","title":"观察者模式","keywords":"","body":"Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/shi-pei-qi-mo-shi.html":{"url":"she-ji-mo-shi/shi-pei-qi-mo-shi.html","title":"适配器模式","keywords":"","body":"系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，将原来转换成你想要的 对现有的服务，通过适配模式可以实现对不同调用者提供相同行为上的不同表象 实现原服务接口 持有原服务 抽象可变行为 调用者依赖不同可变行为实现值 如图： 对原服务提供相同行为，不同表象 适配对象与基础服务提供相同行为（继承相同接口），通过封装原服务对 使用适配对象提供服务，在执行相同行为时候适配对象通过对（数据适配或者功能适配）返回 数据适配，功能适配，在原来接口上提供标准功能在此扩张，或者对基础数进行真强-满足调用者需求 适配需求-方法或者数据 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/she-ji-mo-shi/jie-gou-xing-mo-shi.html":{"url":"she-ji-mo-shi/she-ji-mo-shi/jie-gou-xing-mo-shi.html","title":"结构型模式","keywords":"","body":"通过对多个类和对象进行组合得到复杂结构的类，一般使用继承继承或者成员变量引用形式来实现。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/she-ji-mo-shi/jie-gou-xing-mo-shi/zhuang-shi-mo-shi.html":{"url":"she-ji-mo-shi/she-ji-mo-shi/jie-gou-xing-mo-shi/zhuang-shi-mo-shi.html","title":"装饰模式","keywords":"","body":"Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"she-ji-mo-shi/she-ji-mo-shi/chuang-jian-xing-mo-shi.html":{"url":"she-ji-mo-shi/she-ji-mo-shi/chuang-jian-xing-mo-shi.html","title":"创建型模式","keywords":"","body":"对对象的实例化过程进行抽象，这使得一个系统可以不用关心这些对象是如何创建，组合，呈现的，对于类创建模式来说通过使用继承改变实例化的类，对于对象创建模式来说通过使用代理来实例化所需要的对象。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"gao-nei-ju-yu-di-ou-he.html":{"url":"gao-nei-ju-yu-di-ou-he.html","title":"高内聚与低耦合","keywords":"","body":"高内聚就是说相关度比较高的部分尽可能的集中不要分散，低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖 起因：模块独立性指每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，两个定性的度量标准――内聚性和耦合性。 内聚性又称块内联系。指单个模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素联系的越紧密，则它的内聚性就越高，就是常说的高内聚。特点：最充分的利用模块中每一个元素的功能，达到功能实现最大化，内聚性越强越好，用最小的资源干最大的事情！ 耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。特点：项目中的各个模块之间的关联要尽可能的小，耦合性（相互间的联系）越低越好，减小“牵一发而动全身”的可能性！ 高内聚低耦合是软件设计的一个基本原则，说的是在程序的各个模块中，尽量让每个模块独立，相关的处理尽量在单个模块中完成，就是俗话说的：该干嘛干嘛去！优点：能提降低各模块的之间的联系，减少“牵一发而动全身”的几率，提高开发效率，降低升级维护成本，也便于进行单元测试，提高软件质量。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"gao-nei-ju-yu-di-ou-he/ru-he-ba-wo-ou-he.html":{"url":"gao-nei-ju-yu-di-ou-he/ru-he-ba-wo-ou-he.html","title":"如何把握耦合","keywords":"","body":"耦合（依赖）关系的种类 零耦合（Nil Coupling）关系：两个类没有耦合关系 具体耦合（Concrete Coupling）关系：发生在两个具体的（可实例化的）类之间，经由一个类对另一个具体类的直接引用造成。 抽象耦合（Abstract Coupling）关系：发生在一个具体类和一个抽象类（或接口）之间，使两个必须发生关系的类之间存有最大的灵活性。 如何把握耦合 我们应该尽可能的避免实现继承，原因如下： 1 失去灵活性，使用具体类会给底层的修改带来麻烦。 2 耦合问题，耦合是指两个实体相互依赖于对方的一个量度。程序员每天都在(有意识地或者无意识地)做出影响耦合的决定：类耦合、API耦合、应用程序耦合等等。在一个用扩展的继承实现系统中，派生类是非常紧密的与基类耦合，而且这种紧密的连接可能是被不期望的。如B extends A ，当B不全用A中的所有methods时，这时候，B调用的方法可能会产生错误! 我们必须客观的评价耦合度，系统之间不可能总是松耦合的，那样肯定什么也做不了。 我们决定耦合程度的依据是什么 简单的说，就是根据需求的稳定性，来决定耦合的程度。对于稳定性高的需求，不容易发生变化的需求，我们完全可以把各类设计成紧耦合的(我们虽然讨论类之间的耦合度，但其实功能块、模块、包之间的耦合度也是一样的)，因为这样可以提高效率，而且我们还可以使用一些更好的技术来提高效率或简化代码，例如c# 中的内部类技术。可是，如果需求极有可能变化，我们就需要充分的考虑类之间的耦合问题，我们可以想出各种各样的办法来降低耦合程度，但是归纳起来，不外乎增加抽象的层次来隔离不同的类，这个抽象层次可以是抽象的类、具体的类，也可以是接口，或是一组的类。我们可以用一句话来概括降低耦合度的思想：\"针对接口编程，而不是针对实现编程。在我们进行编码的时候，都会留下我们的指纹，如public的多少，代码的格式等等。我们可以耦合度量评估重新构建代码的风险。因为重新构建实际上是维护编码的一种形式，维护中遇到的那些麻烦事在重新构建时同样会遇到。我们知道在重新构建之后，最常见的随机bug大部分都是不当耦合造成的 。 如果不稳定因素越大，它的耦合度也就越大。 某类的不稳定因素=依赖的类个数/被依赖的类个数 依赖的类个数＝ 在编译此类的时被编译的其它类的个数总和 怎样将大系统拆分成效系统 解决这个问题的一个思路是将许多类集合成一个更高层次的单位,形成一个高内聚、低耦合的类的集合，这是我们设计过程中应该着重考虑的问题！ 耦合的目标是维护依赖的单向性，有时我们也会需要使用坏的耦合。在这种情况下，应当小心记录下原因，以帮助日后该代码的用户了解使用耦合真正的原因。 怎样做到依赖倒转 以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，因此，里氏代换原则是依赖倒转原则的基础。 在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性，如果一个具体类发生变化的可能性非常小，那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。 层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。 依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到： 1、任何变量都不应该持有一个指向具体类的指针或者引用。 2、任何类都不应该从具体类派生。 3、任何方法都不应该覆写它的任何基类中的已经实现的方法。 依赖倒转原则的优缺点 依赖倒转原则虽然很强大，但却最不容易实现。因为依赖倒转的缘故，对象的创建很可能要使用对象工厂，以避免对具体类的直接引用，此原则的使用可能还会导致产生大量的类，对不熟悉面向对象技术的工程师来说，维护这样的系统需要较好地理解面向对象设计。 依赖倒转原则假定所有的具体类都是会变化的，这也不总是正确。有一些具体类可能是相当稳定，不会变化的，使用这个具体类实例的应用完全可以依赖于这个具体类型，而不必为此创建一个抽象类型。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "},"zhong-gou-yu-mo-shi.html":{"url":"zhong-gou-yu-mo-shi.html","title":"重构与模式","keywords":"","body":"第一章 过度设计：是指代码的灵活性和复杂性超出所需。 第二章 ☛重构是一种保持行为的转换。 第三章 ☛每一个模式都是由三部分组成的规则，他表达的是某一环境，一个问题以及解决问题的方案之间的关系。 ☛模式痴迷：对模式过于依赖。 第四章 ☛代码坏味道 ●代码重复（Duplicated Code） 通常可以通过形成Template Method重构。 ●方法过长（Long Method） ●条件逻辑太复杂（Conditional Complexity） ●基本类型迷恋（Primitive Obsession） ●不恰当的暴漏（Indecent Exposure） 用工厂封装类重构可以去除这种坏味道。 ●解决方案蔓延（Solution Sprawl） ●异曲同工的类（Alternative Classes with Different Interfaces） ●冗余类（Lazy class） ●类过大（Large Class） ●分支语句（Switch Statement） ●组合爆炸（Combinatorial Explosion） ●怪异解决方案（Oddball Solution） 第六章 ☛解决各种设计代码的问题 ●用Creation Method 替换构造函数 类中有多个构造函数，很难决定用哪一个。 ● 将创建知识版移到Factory 用来实例化的一个类的数据和代码在多个类中到处都是。移到factory。 ●用Factory封装类 直接实例化处在同一包结构中，实现同一接口的多个类。把类的构造函数声明为非公共的，并通过Factory来创建他们的实例。 ●用Factory Method 引入多态的创建。 一个层次中的类都类似的实现一个方法，只是创建的步骤不同。创建调用Factory Method来处理实例化的方法的唯一超类版本。 第七章 ☛简化 ●组合方法 你无法迅速的理解一个方法的逻辑。把方法的逻辑转换成几个同一细节层面上的，能够说明意图的步骤。 ●用Strategy替换条件逻辑。 方法中条件逻辑控制着应该执行哪个计算的变体，为每一个变体创建一个Strategy并使方法把计算委托到Strategy实例。 ●将装饰功能搬移到Decorator 代码向类的核心职责提供装饰的功能。将装饰代码搬移到Decorator。 ●用state替换状态改变条件语句 控制一个对象的转换条件的表达式过于复杂。 用处理特殊状态和转换的State类来替换条件语句。 Copyright © baihui.com 111 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 06:37:48 "}}